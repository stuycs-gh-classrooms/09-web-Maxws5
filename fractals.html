<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <link id="stylesheet" href="fractals.css" rel="stylesheet">
    <title>Fractals</title>
</head>

<body>
    <h1>FRACTAL FUN!</h1>
    <h2>Sierpinski Triangle</h2>
    <h3>Regular</h3>
      <img src="spert.png" height="300px">
    <h3>Modified</h3>
      <img src="tri_mod.png" height="300px">
      <p>The modifiocations I made for this one are pretty interesting. The
        first is color based. After the first recursion, the turtles color is
        chnaged so that it has a rgb value of 50 times the dpeth for red, and
        then zero for blue and green. This is replicated after the two other
        recursions, but with green and blue instead. The second modifiaction is
        on length. There are actually two parts. First, length is halfed everytime
        the function is run again. Second, instead of just going forward 'length'
        the turtle goes forward length divided by four times the depth. </p>
        <hr>
        <br>
        <hr>
    <h3>Code</h3>
    <pre><code>
    def draw_sierpinski(t, depth, length):
      if depth > 1:
        draw_sierpinski(t, depth-1, length/2)
        t.color(depth * 50, 0, 0)
        t.fd(length/4*depth)
        draw_sierpinski(t, depth-1, length/2)
        t.color(0, depth * 50, 0)
        t.lt(120)
        t.fd(length/4*depth)
        t.rt(120)
        draw_sierpinski(t, depth-1, length/2)
        t.color(0,0,depth * 50)
        t.rt(120)
        t.fd(length/4*depth)
        t.lt(120)
      else:
        time = 3
        while time > 0:
            t.color('blue')
            t.fd(length)
            t.lt(120)
            time-=1

  draw_sierpinski(max_jr, 5,200)
    </code></pre>
    <hr>
    <br>
      <hr>

    <h2>Kotch Curve</h2>
    <h3>Regular</h3>
      <img src="kotch.png" height="300px">
    <h3>Modified</h3>
      <img src="kotch_mod.png" height="300px">
      <p>The modifiocations on the kotch curve are all random. First,
        the color is completely randomized at the top of the 'if' function.
        This makes every segment have a different color. Second, the turns are
        randomized within ten degrees of their original value.</p>
        <hr>
        <br>
          <hr>
    <h3>Code</h3>
    <pre><code>
      def draw_koch(t, depth, length):
        if depth > 0:
          t.color(random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
          draw_koch(t, depth-1, length)
          t.lt (random.randint(50, 70))
          draw_koch(t, depth-1, length)
          t.rt (random.randint(110, 130))
          draw_koch(t, depth-1, length)
          t.lt (random.randint(50, 70))
          draw_koch(t, depth-1, length)
        else:
          t.fd (length)

draw_koch(max_jr, 4, 20)
</code></pre>
<hr>
<br>
  <hr>

    <h2>Fractal Tree</h2>
    <h3>Regular</h3>
      <img src="tree.png" height="300px">
    <h3>Modified</h3>
      <img src="spert_mod.png" height="300px">
      <p>These modifications are mostly based off of code at the top
        of the function. First, the color is either red if the depth
        is a multiple of three, or otherwise it in blue. Second, the
        angle for the next functions are either doubled if the depth is odd
        or halved if the depth is even.</p>
    <h3>Code</h3>\
    <pre><code>
      max_jr.lt(90)
def tree(t, depth, length, angle):
    if depth % 3 == 0:
        t.color('red')
    else:
        t.color('blue')
    if depth % 2 == 0:
        w = 0.5
    else:
        w = 2
    if depth > 1:
        t.pendown()
        t.fd(length)
        t.rt(angle)
        tree(t, depth-1, length, angle/w)
        t.lt(angle*2)
        tree(t, depth-1, length, angle/w)
        t.rt(angle)
        t.bk(length)
    else:
        t.penup()
        t.fd(length)
        t.bk(length)

tree(max_jr, 8, 30, 60)
</code></pre>
</body>
</html>
